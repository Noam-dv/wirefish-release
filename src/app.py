from PySide6.QtWidgets import *
from PySide6.QtGui import QFont, QColor, QBrush
from PySide6.QtCore import Qt, QTimer
from itertools import islice
from sniffer import Sniffer
from cap_list import cap_list

class WireFish(QWidget):
    MAX_ROWS = 1500
    POLL_INTERVAL = 300

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Wirefish")
        self.setGeometry(100, 100, 900, 520)

        self.sniffer = None
        self.last_r = 0
        self.curfilter = ""

        # --- ui ---  
        layout = QVBoxLayout(self)
        controls = QHBoxLayout()

        self.status = QLabel("press to begin sniffing")
        self.start_btn = QPushButton("sniff")
        self.pcap_btn = QPushButton("save to PCAP [OFF]")

        self.filter_inp = QLineEdit(placeholderText="type filter")
        self.clear_btn = QPushButton("clear")
        self.guide_btn = QPushButton("filter guide")
        self.iface_combo = QComboBox()
        arr = [f"[DEFAULT] - {Sniffer.d_iface()} "] # default itnerface
        #add the rest of the interfaces just incase user wants ig
        arr += Sniffer.ret_ifaces()
        self.iface_combo.addItems(arr)

        self.table = QTableWidget(0,1)
        self.table.setHorizontalHeaderLabels(["Captured "])
        self.table.horizontalHeader().setSectionResizeMode(0,QHeaderView.Stretch)
        self.table.verticalHeader().setVisible(False)
        self.table.setWordWrap(False)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setAlternatingRowColors(True)

        #console style generated by Chatgpt
        self.setStyleSheet("""
        QWidget { background: #111; color: #ddd; }
        QHeaderView::section { background: #222; color: #bbb; padding: 4px 6px; border: none; }
        QTableWidget { gridline-color: #333; font-family: Consolas, 'Courier New', monospace; font-size: 12px; }
        QPushButton { background: #1f1f1f; border: 1px solid #333; padding: 4px 10px; }
        QPushButton:hover { background: #272727; }
        QLineEdit { background: #1a1a1a; border: 1px solid #333; padding: 4px 6px; }
        """)

        # controls row
        controls.addWidget(self.start_btn)
        controls.addWidget(self.pcap_btn)
        controls.addWidget(QLabel("filter:"))
        controls.addWidget(self.filter_inp)
        controls.addWidget(self.clear_btn)
        controls.addWidget(self.guide_btn)
        controls.addWidget(self.iface_combo)
        layout.addWidget(self.status)
        layout.addLayout(controls)
        layout.addWidget(self.table)

        #event handler
        self.start_btn.clicked.connect(self.start_sniff)
        self.pcap_btn.clicked.connect(self.toggle_pcap)
        self.guide_btn.clicked.connect(self.show_filter_guide)
        self.filter_inp.returnPressed.connect(self.apply_filter)
        self.clear_btn.clicked.connect(self.clear_filter)

        # timer
        self.timer = QTimer(self, interval=self.POLL_INTERVAL)
        self.timer.timeout.connect(self.capture_packets)

        # protocol colors
        self.mono = QFont("Consolas") if QFont("Consolas").family() else QFont("Courier New")
        self.bgcolsproto = {
            "TCP": QColor("#1b3a63"),
            "UDP": QColor("#5a4a14"),
        }
        self.bgcoldefault = QColor("#2b2b2b")

    def start_sniff(self):
        if self.sniffer:
            self.reset_capture()
            return
        
        ifacetouse = self.iface_combo.currentText()
        #the format of the default iface is [DEFAULT] - kodijasoidj
        #so i split by - get second field then strip for the spaces
        #i make sure to do this only when its default ofc 
        #if "[DEFAULT]" in ifacetouse:
        #    ifacetouse = ifacetouse.split(" - ")[1]
        #    print(ifacetouse) # compare cuz this dosent work for some raeson (?)
        #    print(Sniffer.d_iface())

        #after allt hat im just now realizing i could just check if theres default 
        #and if there is just pass conf.iface ðŸ˜ðŸ˜ðŸ˜
        
        if "[DEFAULT]" in ifacetouse:
            ifacetouse = Sniffer.d_iface()
        self.sniffer = Sniffer("udp or tcp", ifacetouse)
        self.sniffer.start_sniff()
        self.status.setText("started sniffing (default filter tcp or udp)")
        self.start_btn.setText("reset")
        self.timer.start()

    def reset_capture(self):
        #stop sniffer n close writer
        try:
            if self.sniffer:
                self.sniffer.stop()
        except Exception as e:
            print(f"stop error: {e}")

        self.sniffer = None
        self.timer.stop()

        cap_list().clear() #clear buffer and ui
        self.last_r = 0
        self.table.setRowCount(0)
        self.status.setText("reset, press to begin sniffing 8)")
        self.start_btn.setText("sniff")
        self.pcap_btn.setText("save to PCAP [OFF]")

    def toggle_pcap(self):
        if not self.sniffer:
            return
        self.sniffer.toggle_writer()
        self.pcap_btn.setText(f"save to PCAP {'[ON]' if self.sniffer.write else '[OFF]'}")

    def show_filter_guide(self):
        QMessageBox.information(
            self,
            "filter guide",
            "filters view not the sniffer (for pcap saving)\nnot case sensetive\n\n"
            "examples:\n"
            "  tcp\n  udp\n  127.0.0.1\n 1234 (port)\n"
        )

    # ---- filter ----
    def apply_filter(self):
        self.curfilter = self.filter_inp.text().lower().strip()
        self.rebuild_view()

    def clear_filter(self):
        self.filter_inp.clear()
        self.curfilter = ""
        self.rebuild_view()

    def passes_filter(self, raw):
        f = self.curfilter
        if not f: #no filter
            return True
        return f in raw.lower()

    # ---- capture----
    def capture_packets(self):
        dq = cap_list()
        curr_len = len(dq)

        if self.last_r > curr_len:  #wrapped
            self.last_r = 0

        if self.last_r == curr_len:
            return

        new_packets = list(islice(dq, self.last_r, curr_len))
        self.last_r = curr_len

        sb = self.table.verticalScrollBar()
        at_bottom = sb.value() >= sb.maximum() - 2

        self.table.setUpdatesEnabled(False)
        for raw in new_packets:
            if self.passes_filter(raw):
                self.appendrow(raw)
        self.cap_view_rows()
        self.table.setUpdatesEnabled(True)

        if at_bottom:
            self.table.scrollToBottom()

    def rebuild_view(self):
        dq = cap_list()

        self.table.setUpdatesEnabled(False)
        self.table.clearContents()
        self.table.setRowCount(0)

        m = [raw for raw in dq if self.passes_filter(raw)] #basically all packets that match filter
        if len(m) > self.MAX_ROWS:
            m = m[-self.MAX_ROWS:]
        for raw in m:
            self.appendrow(raw)

        self.table.setUpdatesEnabled(True)
        self.table.scrollToBottom()

    # ---- row helpers ----
    def appendrow(self, raw):
        r = self.table.rowCount()
        self.table.insertRow(r)
        self.table.setItem(r, 0, self.makerow(raw))

    def makerow(self, raw):
        p, t = self.split_proto(raw)
        display = f"[{p}] {t}" if t else raw

        it = QTableWidgetItem(display)
        it.setFont(self.mono)
        it.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        it.setBackground(QBrush(self.bgcolsproto.get(p, self.bgcoldefault)))
        it.setForeground(QBrush(QColor("#e6e6e6")))
        return it

    @staticmethod # static incase needed for other classes in future
    def split_proto(raw):
        a = raw.split("||", 1)
        protocol = (a[0].strip() if a else "") or "OTHER"
        txt = a[1].strip() if len(a) > 1 else ""
        return protocol, txt

    def cap_view_rows(self):
        rc = self.table.rowCount()
        if rc <= self.MAX_ROWS:
            return
        remove = rc - self.MAX_ROWS
        #remove oldest for overflow purposes
        for _ in range(remove):
            self.table.removeRow(0)